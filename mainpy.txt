# =========================
# EncarreraOK - MVP deslindes digitales
# main.py (VERSIÓN CORREGIDA Y ESTABLE)
# =========================

from fastapi import FastAPI, Request, Form, HTTPException, UploadFile, File
from fastapi.responses import HTMLResponse
from jinja2 import Environment, DictLoader, select_autoescape
from pydantic import BaseModel
from datetime import datetime, date
import sqlite3
import os
import stat
import hashlib
import re
import base64
import uuid
import shutil
import logging
from typing import Optional, List, Dict, Any

# ---------------------------------------------------------------------
# LIMITES (APP-SIDE)
# ---------------------------------------------------------------------
MAX_IMAGE_DOC_MB = 4
MAX_FIRMA_MB = 1
MAX_AUDIO_MB = 5

# ---------------------------------------------------------------------
# DESLINDE BASE
# ---------------------------------------------------------------------
DESLINDE_TEXTO_BASE = """DESLINDE DE RESPONSABILIDAD Y ACEPTACIÓN DE RIESGOS

Declaro que participo en el evento deportivo {{NOMBRE_EVENTO}}, organizado por {{ORGANIZADOR}}, de manera voluntaria y bajo mi exclusiva responsabilidad.

Reconozco que la participación en actividades deportivas implica riesgos inherentes, incluyendo, pero no limitándose a, caídas, lesiones físicas, traumatismos, accidentes cardiovasculares, condiciones climáticas adversas y otros riesgos propios de la actividad.

Declaro encontrarme en condiciones físicas y de salud adecuadas para participar, y que he sido debidamente informado/a sobre las características del evento.

Eximo de toda responsabilidad civil, penal y administrativa al organizador, auspiciantes, colaboradores, personal médico, autoridades y cualquier otra persona vinculada a la organización del evento, por cualquier daño, lesión o perjuicio que pudiera sufrir antes, durante o después de mi participación.

Autorizo la utilización de mi imagen, voz y datos personales con fines de difusión, promoción y registro del evento, sin derecho a compensación económica.

Declaro haber leído, comprendido y aceptado íntegramente el presente deslinde de responsabilidad.
"""

# ---------------------------------------------------------------------
# APP
# ---------------------------------------------------------------------
app = FastAPI(title="EncarreraOK")

# ---------------------------------------------------------------------
# LOGGING
# ---------------------------------------------------------------------
LOG_DIR = "/var/log/encarreraok"
LOG_FILE = os.path.join(LOG_DIR, "app.log")

def setup_logging():
    try:
        os.makedirs(LOG_DIR, exist_ok=True)
        logging.basicConfig(
            filename=LOG_FILE,
            level=logging.INFO,
            format="%(asctime)s [%(levelname)s] %(message)s"
        )
    except Exception:
        logging.basicConfig(level=logging.INFO)

setup_logging()

# ---------------------------------------------------------------------
# TEMPLATES (sin cambios funcionales)
# ---------------------------------------------------------------------
templates_env = Environment(
    loader=DictLoader({}), autoescape=select_autoescape(["html"])
)

def fecha_ddmmaaaa(value: str) -> str:
    try:
        y, m, d = value.split("-")
        return f"{d}/{m}/{y}"
    except Exception:
        return value

templates_env.filters["fecha_ddmmaaaa"] = fecha_ddmmaaaa

# ---------------------------------------------------------------------
# DB & STORAGE
# ---------------------------------------------------------------------
DB_PATH = "/var/lib/encarreraok/encarreraok.sqlite3"
BASE_DIR = os.path.dirname(DB_PATH)
EVIDENCIAS_DIR = os.path.join(BASE_DIR, "evidencias")
FIRMAS_DIR = os.path.join(EVIDENCIAS_DIR, "firmas")
DOCUMENTOS_DIR = os.path.join(EVIDENCIAS_DIR, "documentos")
AUDIOS_DIR = os.path.join(EVIDENCIAS_DIR, "audios")

def ensure_dirs():
    for d in [BASE_DIR, EVIDENCIAS_DIR, FIRMAS_DIR, DOCUMENTOS_DIR, AUDIOS_DIR]:
        os.makedirs(d, exist_ok=True)

def get_connection():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn

# ---------------------------------------------------------------------
# INIT DB (sin inventos)
# ---------------------------------------------------------------------
def init_db():
    ensure_dirs()
    conn = get_connection()
    cur = conn.cursor()

    cur.execute("""
    CREATE TABLE IF NOT EXISTS eventos (
        id INTEGER PRIMARY KEY,
        nombre TEXT,
        fecha TEXT,
        organizador TEXT,
        activo INTEGER,
        req_firma INTEGER DEFAULT 0,
        req_documento INTEGER DEFAULT 0,
        req_audio INTEGER DEFAULT 0
    )""")

    cur.execute("""
    CREATE TABLE IF NOT EXISTS aceptaciones (
        id INTEGER PRIMARY KEY,
        evento_id INTEGER,
        nombre_participante TEXT,
        documento TEXT,
        fecha_hora TEXT,
        ip TEXT,
        user_agent TEXT,
        deslinde_hash_sha256 TEXT,
        firma_path TEXT,
        doc_frente_path TEXT,
        doc_dorso_path TEXT,
        audio_path TEXT
    )""")

    cur.execute("""
    CREATE TABLE IF NOT EXISTS deslindes (
        id INTEGER PRIMARY KEY,
        evento_id INTEGER,
        texto TEXT,
        hash_sha256 TEXT,
        activo INTEGER,
        fecha_creacion TEXT,
        creado_por TEXT
    )""")

    conn.commit()
    conn.close()

# ---------------------------------------------------------------------
# HELPERS
# ---------------------------------------------------------------------
def calcular_hash(texto: str) -> str:
    return hashlib.sha256(texto.encode("utf-8")).hexdigest()

def check_size(bytes_len: int, max_mb: int, label: str):
    if bytes_len > max_mb * 1024 * 1024:
        raise HTTPException(
            status_code=413,
            detail=f"{label} supera el máximo permitido ({max_mb}MB)"
        )

# ---------------------------------------------------------------------
# STARTUP
# ---------------------------------------------------------------------
@app.on_event("startup")
def startup():
    init_db()
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT COUNT(*) c FROM eventos")
    if cur.fetchone()["c"] == 0:
        cur.execute("""
            INSERT INTO eventos (id,nombre,fecha,organizador,activo)
            VALUES (1,'Carrera 10K Montevideo',?,?,1)
        """, (date.today().isoformat(), "Encarrera"))
        conn.commit()

    cur.execute("SELECT id,nombre,organizador FROM eventos")
    eventos = cur.fetchall()
    for e in eventos:
        cur.execute("SELECT COUNT(*) c FROM deslindes WHERE evento_id=? AND activo=1", (e["id"],))
        if cur.fetchone()["c"] == 0:
            texto = DESLINDE_TEXTO_BASE.replace("{{NOMBRE_EVENTO}}", e["nombre"]).replace(
                "{{ORGANIZADOR}}", e["organizador"]
            )
            cur.execute("""
                INSERT INTO deslindes (evento_id,texto,hash_sha256,activo,fecha_creacion,creado_por)
                VALUES (?,?,?,?,?,?)
            """, (
                e["id"], texto, calcular_hash(texto), 1,
                datetime.utcnow().isoformat() + "Z", "sistema"
            ))
            conn.commit()
    conn.close()

# ---------------------------------------------------------------------
# GET FORM
# ---------------------------------------------------------------------
@app.get("/e/{evento_id}", response_class=HTMLResponse)
def form(evento_id: int, request: Request):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT * FROM eventos WHERE id=?", (evento_id,))
    evento = cur.fetchone()
    if not evento:
        raise HTTPException(404, "Evento no encontrado")

    cur.execute("SELECT * FROM deslindes WHERE evento_id=? AND activo=1", (evento_id,))
    deslinde = cur.fetchone()
    conn.close()

    if not deslinde:
        raise HTTPException(400, "No hay deslinde activo")

    tpl = templates_env.get_template("evento_form.html")
    return HTMLResponse(tpl.render(evento=dict(evento), deslinde_texto=deslinde["texto"], request=request))

# ---------------------------------------------------------------------
# POST ACCEPT
# ---------------------------------------------------------------------
@app.post("/e/{evento_id}", response_class=HTMLResponse)
def aceptar(
    evento_id: int,
    request: Request,
    nombre_participante: str = Form(...),
    documento: str = Form(...),
    acepto: Optional[str] = Form(None),
    firma_base64: Optional[str] = Form(None),
    doc_frente: Optional[UploadFile] = File(None),
    doc_dorso: Optional[UploadFile] = File(None),
    audio_base64: Optional[str] = Form(None),
):
    if acepto is None:
        raise HTTPException(400, "Debe aceptar el deslinde")

    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT * FROM eventos WHERE id=?", (evento_id,))
    evento = cur.fetchone()
    if not evento or not evento["activo"]:
        raise HTTPException(400, "Evento inválido")

    cur.execute("SELECT * FROM deslindes WHERE evento_id=? AND activo=1", (evento_id,))
    deslinde = cur.fetchone()
    conn.close()

    ip = request.client.host if request.client else "0.0.0.0"
    ua = request.headers.get("user-agent", "")
    fecha = datetime.utcnow().isoformat() + "Z"

    firma_path = None
    if evento["req_firma"]:
        if not firma_base64:
            raise HTTPException(400, "Firma requerida")
        data = base64.b64decode(firma_base64.split(",")[-1])
        check_size(len(data), MAX_FIRMA_MB, "Firma")
        firma_path = os.path.join(FIRMAS_DIR, f"{uuid.uuid4()}.png")
        with open(firma_path, "wb") as f:
            f.write(data)

    doc_frente_path = doc_dorso_path = None
    if evento["req_documento"]:
        if not doc_frente or not doc_dorso:
            raise HTTPException(400, "Documento requerido")

        for label, file, dest in [
            ("Documento frente", doc_frente, "_frente"),
            ("Documento dorso", doc_dorso, "_dorso"),
        ]:
            file.file.seek(0, os.SEEK_END)
            size = file.file.tell()
            file.file.seek(0)
            check_size(size, MAX_IMAGE_DOC_MB, label)
            path = os.path.join(DOCUMENTOS_DIR, f"{uuid.uuid4()}{dest}.jpg")
            with open(path, "wb") as out:
                shutil.copyfileobj(file.file, out)
            if dest == "_frente":
                doc_frente_path = path
            else:
                doc_dorso_path = path

    audio_path = None
    if evento["req_audio"]:
        if not audio_base64:
            raise HTTPException(400, "Audio requerido")
        data = base64.b64decode(audio_base64.split(",")[-1])
        check_size(len(data), MAX_AUDIO_MB, "Audio")
        audio_path = os.path.join(AUDIOS_DIR, f"{uuid.uuid4()}.webm")
        with open(audio_path, "wb") as f:
            f.write(data)

    conn = get_connection()
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO aceptaciones
        (evento_id,nombre_participante,documento,fecha_hora,ip,user_agent,deslinde_hash_sha256,
         firma_path,doc_frente_path,doc_dorso_path,audio_path)
        VALUES (?,?,?,?,?,?,?,?,?,?,?)
    """, (
        evento_id,
        nombre_participante.strip(),
        re.sub(r"[.\-\s]", "", documento),
        fecha,
        ip,
        ua,
        deslinde["hash_sha256"],
        firma_path,
        doc_frente_path,
        doc_dorso_path,
        audio_path
    ))
    conn.commit()
    aid = cur.lastrowid
    conn.close()

    tpl = templates_env.get_template("confirmacion.html")
    return HTMLResponse(tpl.render(
        nombre_participante=nombre_participante,
        evento=dict(evento),
        aceptacion_id=aid,
        fecha_hora=fecha
    ))
